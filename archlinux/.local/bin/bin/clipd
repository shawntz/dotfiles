#!/usr/bin/env python3
"""
Secure Clipboard Manager Daemon
- Password-protected AES-256 encryption 
- 30-day automatic cleanup
- Sensitive content detection and exclusion
- Fast SQLite storage with indexing
"""

import os
import sys
import time
import json
import sqlite3
import hashlib
import subprocess
import signal
import re
import getpass
from datetime import datetime, timedelta
from pathlib import Path
from threading import Thread, Event

def check_dependencies():
    """Check and install required dependencies on first run"""
    missing_deps = []
    
    # Check for required modules
    try:
        from cryptography.fernet import Fernet
        from cryptography.hazmat.primitives import hashes
        from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
        import base64
    except ImportError:
        missing_deps.append('cryptography')
    
    try:
        import toml
    except ImportError:
        missing_deps.append('toml')
    
    # Check for wl-clipboard
    if not (subprocess.run(['which', 'wl-paste'], capture_output=True).returncode == 0 and
            subprocess.run(['which', 'wl-copy'], capture_output=True).returncode == 0):
        print("âŒ wl-clipboard is required for Wayland clipboard access")
        print("Install with: sudo pacman -S wl-clipboard")
        sys.exit(1)
    
    if missing_deps:
        print("ðŸ” First-time setup: Installing required dependencies...")
        
        # Determine pip command
        pip_cmd = 'pip3' if subprocess.run(['which', 'pip3'], capture_output=True).returncode == 0 else 'pip'
        
        for dep in missing_deps:
            print(f"ðŸ“¦ Installing {dep}...")
            result = subprocess.run([pip_cmd, 'install', '--user', dep], capture_output=True, text=True)
            if result.returncode != 0:
                print(f"âŒ Failed to install {dep}:")
                print(result.stderr)
                print(f"Please install manually: {pip_cmd} install --user {dep}")
                sys.exit(1)
        
        print("âœ… Dependencies installed successfully!")
        print("ðŸ”„ Restarting daemon with dependencies loaded...")
        print("")
        # Re-exec the script to reload with new dependencies
        os.execv(sys.executable, [sys.executable] + sys.argv)

# Check dependencies before importing
check_dependencies()

# Now safe to import
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes  
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import toml

class SecureClipboardManager:
    def __init__(self, password=None):
        self.config_dir = Path.home() / '.config' / 'clipd'
        self.config_dir.mkdir(mode=0o700, exist_ok=True)  # Only owner access
        
        # Create ignore patterns file on first run
        self.setup_ignore_patterns_file()
        
        self.db_path = self.config_dir / 'clips.db'
        self.salt_file = self.config_dir / '.salt'
        self.config_file = self.config_dir / 'clipd.toml'
        self.password_cache_file = self.config_dir / '.password_cache'
        
        # Load configuration
        self.config = self.load_config()
        
        self.max_entries = self.config.get('max_entries', 10000)
        self.max_days = self.config.get('max_days', 30)
        self.check_interval = self.config.get('check_interval', 1.0)
        self.password_cache_days = self.config.get('password_cache_days', 14)
        self.require_password_for_access = self.config.get('require_password_for_access', False)
        self.last_clip = ""
        
        # Load user-configurable ignore patterns (similar to Clipboard project)
        self.load_ignore_patterns()
        
        # Default sensitive content patterns
        self.default_sensitive_patterns = [
            r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b',  # Credit cards
            r'\b\d{3}-\d{2}-\d{4}\b',  # SSN
            r'(?i)password[:\s=]\s*\S+',   # Password fields
            r'(?i)token[:\s=]\s*\S+',      # API tokens
            r'(?i)key[:\s=]\s*\S+',        # Keys
            r'(?i)secret[:\s=]\s*\S+',     # Secrets
            r'\b[A-Za-z0-9+/]{40,}={0,2}\b',  # Long base64 (likely keys)
            r'(?i)(api|auth|bearer)\s+[a-z0-9]{20,}',  # API tokens
            r'ssh-[a-z0-9]+\s+[A-Za-z0-9+/]{50,}',  # SSH keys
            r'-----BEGIN [A-Z ]+-----',  # PEM format keys
        ]
        
        self.stop_event = Event()
        
        if password:
            self.setup_encryption(password)
            self.setup_database()
            
    def load_config(self):
        """Load configuration from TOML file"""
        default_config = {
            'max_entries': 10000,
            'max_days': 30,
            'check_interval': 1.0,
            'password_cache_days': 14,  # Cache password for 14 days
            'require_password_for_access': False,  # Don't require password for clip-search
        }
        
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    user_config = toml.load(f)
                default_config.update(user_config)
            except Exception as e:
                print(f"Warning: Could not load config file: {e}")
        else:
            # Create default config file
            self.create_default_config()
            
        return default_config
        
    def create_default_config(self):
        """Create default configuration file"""
        default_config = '''# Clipboard Manager Configuration

# Maximum number of clipboard entries to store
max_entries = 10000

# Number of days to keep clipboard history
max_days = 30

# How often to check clipboard (seconds)
check_interval = 1.0

# How many days to cache the password (0 = always ask)
password_cache_days = 14

# Require password when accessing clipboard history via clip-search
# If false, password is only needed to start daemon
require_password_for_access = false
'''
        
        with open(self.config_file, 'w') as f:
            f.write(default_config)
        
    def setup_encryption(self, password):
        """Setup password-based encryption"""
        # Generate or load salt
        if self.salt_file.exists():
            with open(self.salt_file, 'rb') as f:
                salt = f.read()
        else:
            salt = os.urandom(32)
            # Secure file creation
            old_umask = os.umask(0o077)
            with open(self.salt_file, 'wb') as f:
                f.write(salt)
            os.umask(old_umask)
            
        # Derive key from password + salt
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,  # High iteration count for security
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        self.fernet = Fernet(key)
        
        # Cache password for configured duration
        self.cache_password(password)
        
    def cache_password(self, password):
        """Cache encrypted password for configured duration"""
        if self.password_cache_days > 0:
            # Create a simple hash to verify password without storing it
            password_hash = hashlib.sha256(password.encode()).hexdigest()
            cache_data = {
                'hash': password_hash,
                'timestamp': time.time()
            }
            
            # Store cache with secure permissions
            old_umask = os.umask(0o077)
            with open(self.password_cache_file, 'w') as f:
                json.dump(cache_data, f)
            os.umask(old_umask)
            
    def is_password_cached(self, password):
        """Check if password is cached and valid"""
        if self.password_cache_days == 0:
            return False
            
        if not self.password_cache_file.exists():
            return False
            
        try:
            with open(self.password_cache_file, 'r') as f:
                cache_data = json.load(f)
                
            # Check if cache is still valid
            cache_age = time.time() - cache_data['timestamp']
            if cache_age > (self.password_cache_days * 24 * 60 * 60):
                os.unlink(self.password_cache_file)
                return False
                
            # Check if password matches
            password_hash = hashlib.sha256(password.encode()).hexdigest()
            return password_hash == cache_data['hash']
            
        except Exception:
            return False
        
    def setup_ignore_patterns_file(self):
        """Create ignore patterns file with template on first run"""
        ignore_file = self.config_dir / 'ignore_patterns.txt'
        
        if not ignore_file.exists():
            template = """# Custom clipboard ignore patterns
# Add regex patterns here to prevent specific content from being stored
# One pattern per line, lines starting with # are comments

# Example patterns:
# .*password.*
# H.*2
# temporary.*
# ^test$

# Uncomment to ignore specific apps or patterns:
# .*1password.*
# .*generated.*
# .*bitwarden.*
# .*lastpass.*
"""
            with open(ignore_file, 'w') as f:
                f.write(template)
    
    def load_ignore_patterns(self):
        """Load user-configurable ignore patterns from config"""
        self.user_ignore_patterns = []
        ignore_file = self.config_dir / 'ignore_patterns.txt'
        
        if ignore_file.exists():
            try:
                with open(ignore_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            self.user_ignore_patterns.append(line)
            except:
                pass
        
    def setup_database(self):
        """Initialize encrypted SQLite database"""
        self.conn = sqlite3.connect(self.db_path, check_same_thread=False)
        
        # Create tables if they don't exist
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS clips (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                content_hash TEXT UNIQUE,
                encrypted_content BLOB,
                timestamp REAL,
                size INTEGER
            )
        ''')
        
        # Test if password is correct by trying to decrypt existing data
        try:
            cursor = self.conn.execute('SELECT encrypted_content FROM clips LIMIT 1')
            row = cursor.fetchone()
            if row:
                self.fernet.decrypt(row[0])  # This will fail if wrong password
        except sqlite3.OperationalError:
            # Database doesn't exist yet or table doesn't exist - this is fine
            pass
        except Exception as e:
            if "clips" not in str(e).lower():  # Only fail if it's not a missing table error
                print("Error: Invalid password or corrupted database")
                print("If this is your first run, try deleting ~/.config/clipd/ and start fresh")
                sys.exit(1)
            
        self.conn.execute('CREATE INDEX IF NOT EXISTS idx_timestamp ON clips(timestamp)')
        self.conn.execute('CREATE INDEX IF NOT EXISTS idx_hash ON clips(content_hash)')
        self.conn.commit()
        
    def is_sensitive(self, content):
        """Check if content contains sensitive information"""
        if not content or len(content.strip()) == 0:
            return True
            
        # Check user ignore patterns first
        for pattern in self.user_ignore_patterns:
            try:
                if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                    return True
            except re.error:
                continue  # Skip invalid regex patterns
                
        # Check default sensitive patterns
        for pattern in self.default_sensitive_patterns:
            if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                return True
                
        # Performance-optimized heuristics
        content_len = len(content)
        if content_len < 2:  # Very short clips
            return True
        if content_len > 50000:  # Very long clips (files, etc)
            return True
        if content.count('\n') > 100:  # Large multiline content
            return True
            
        # Check for common password manager patterns (inspired by Clipboard project)
        if any(word in content.lower() for word in ['generated', 'autofill', '1password', 'bitwarden', 'lastpass']):
            return True
            
        return False
        
    def get_clipboard(self):
        """Get current clipboard content with better error handling"""
        try:
            # Use wl-paste with no-newline flag to avoid issues with piping (Issue #235)
            result = subprocess.run(['wl-paste', '--no-newline'], 
                                  capture_output=True, text=True, timeout=2)
            if result.returncode == 0:
                return result.stdout
            # Fallback to regular wl-paste if --no-newline fails
            result = subprocess.run(['wl-paste'], capture_output=True, text=True, timeout=2)
            return result.stdout if result.returncode == 0 else ""
        except subprocess.TimeoutExpired:
            return ""  # Prevent hangs (Issue #235)
        except Exception:
            return ""
            
    def store_clip(self, content):
        """Encrypt and store clipboard entry"""
        if self.is_sensitive(content):
            return
            
        content_hash = hashlib.sha256(content.encode()).hexdigest()
        
        # Check if already exists
        cursor = self.conn.execute('SELECT id FROM clips WHERE content_hash = ?', (content_hash,))
        if cursor.fetchone():
            # Update timestamp
            self.conn.execute(
                'UPDATE clips SET timestamp = ? WHERE content_hash = ?',
                (time.time(), content_hash)
            )
        else:
            # Store new encrypted entry
            encrypted = self.fernet.encrypt(content.encode())
            self.conn.execute('''
                INSERT INTO clips (content_hash, encrypted_content, timestamp, size)
                VALUES (?, ?, ?, ?)
            ''', (content_hash, encrypted, time.time(), len(content)))
            
        self.conn.commit()
        
    def cleanup_old_entries(self):
        """Remove old entries"""
        cutoff = time.time() - (self.max_days * 24 * 60 * 60)
        self.conn.execute('DELETE FROM clips WHERE timestamp < ?', (cutoff,))
        
        count = self.conn.execute('SELECT COUNT(*) FROM clips').fetchone()[0]
        if count > self.max_entries:
            self.conn.execute('''
                DELETE FROM clips WHERE id NOT IN (
                    SELECT id FROM clips ORDER BY timestamp DESC LIMIT ?
                )
            ''', (self.max_entries,))
            
        self.conn.commit()
        
    def run_daemon(self):
        """Main daemon loop"""
        print("Secure clipboard daemon started")
        
        while not self.stop_event.wait(self.check_interval):
            try:
                current_clip = self.get_clipboard()
                
                if current_clip and current_clip != self.last_clip and len(current_clip.strip()) > 0:
                    self.store_clip(current_clip)
                    self.last_clip = current_clip
                    
                # Cleanup periodically
                if int(time.time()) % 600 == 0:
                    self.cleanup_old_entries()
                    
            except Exception as e:
                print(f"Daemon error: {e}")
                time.sleep(5)
                
    def stop_daemon(self):
        """Stop daemon gracefully"""
        self.stop_event.set()
        if hasattr(self, 'conn'):
            self.conn.close()

def get_password():
    """Prompt for password"""
    return getpass.getpass("Enter clipboard password: ")

def show_welcome_message():
    """Show welcome message on first run"""
    config_dir = Path.home() / '.config' / 'clipd'
    welcome_file = config_dir / '.first_run'
    
    if not welcome_file.exists():
        print("ðŸŽ‰ Welcome to Secure Clipboard Manager!")
        print("")
        print("Features:")
        print("  â€¢ Password-protected AES-256 encryption")
        print("  â€¢ 30-day automatic cleanup")
        print("  â€¢ Smart sensitive content filtering")
        print("  â€¢ FZF-style search interface")
        print("")
        print("Usage:")
        print("  â€¢ Press Super+Q to search clipboard history") 
        print("  â€¢ Use Super+Shift+C/V for copy/paste")
        print("  â€¢ Customize filtering: ~/.config/clipd/ignore_patterns.txt")
        print("")
        print("The daemon will now start and monitor your clipboard...")
        print("")
        
        # Create marker file - ensure directory exists
        config_dir.mkdir(mode=0o700, exist_ok=True)
        with open(welcome_file, 'w') as f:
            f.write(str(int(time.time())))

def main():
    if len(sys.argv) > 1 and sys.argv[1] == 'stop':
        subprocess.run(['pkill', '-f', 'python3.*clipd'])
        return
        
    # Check if already running
    try:
        result = subprocess.run(['pgrep', '-f', 'python.*clipd.*'], capture_output=True)
        if result.returncode == 0 and result.stdout.strip():
            pids = result.stdout.strip().decode().split('\n')
            current_pid = str(os.getpid())
            if any(pid != current_pid for pid in pids):
                print("Clipboard daemon already running")
                return
    except:
        pass
    
    show_welcome_message()
        
    password = get_password()
    if not password:
        print("Password required")
        sys.exit(1)
        
    manager = SecureClipboardManager(password)
    
    # Setup signal handlers
    def handle_signal(signum, frame):
        manager.stop_daemon()
        sys.exit(0)
        
    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)
    
    try:
        manager.run_daemon()
    except KeyboardInterrupt:
        manager.stop_daemon()

if __name__ == '__main__':
    main()